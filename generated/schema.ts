// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class Protocol extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Protocol entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Protocol must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Protocol", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Protocol | null {
    return changetype<Protocol | null>(store.get_in_block("Protocol", id));
  }

  static load(id: string): Protocol | null {
    return changetype<Protocol | null>(store.get("Protocol", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pools(): PoolLoader {
    return new PoolLoader("Protocol", this.get("id")!.toString(), "pools");
  }
}

export class ContractToPoolMapping extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ContractToPoolMapping entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ContractToPoolMapping must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ContractToPoolMapping", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ContractToPoolMapping | null {
    return changetype<ContractToPoolMapping | null>(
      store.get_in_block("ContractToPoolMapping", id),
    );
  }

  static load(id: string): ContractToPoolMapping | null {
    return changetype<ContractToPoolMapping | null>(
      store.get("ContractToPoolMapping", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }
}

export class Pool extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Pool must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Pool", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Pool | null {
    return changetype<Pool | null>(store.get_in_block("Pool", id));
  }

  static load(id: string): Pool | null {
    return changetype<Pool | null>(store.get("Pool", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get protocol(): string {
    let value = this.get("protocol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set protocol(value: string) {
    this.set("protocol", Value.fromString(value));
  }

  get pool(): Bytes | null {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set pool(value: Bytes | null) {
    if (!value) {
      this.unset("pool");
    } else {
      this.set("pool", Value.fromBytes(<Bytes>value));
    }
  }

  get active(): boolean {
    let value = this.get("active");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set active(value: boolean) {
    this.set("active", Value.fromBoolean(value));
  }

  get paused(): boolean {
    let value = this.get("paused");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set paused(value: boolean) {
    this.set("paused", Value.fromBoolean(value));
  }
}

export class Reserve extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Reserve entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Reserve must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Reserve", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Reserve | null {
    return changetype<Reserve | null>(store.get_in_block("Reserve", id));
  }

  static load(id: string): Reserve | null {
    return changetype<Reserve | null>(store.get("Reserve", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get underlyingAsset(): Bytes {
    let value = this.get("underlyingAsset");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set underlyingAsset(value: Bytes) {
    this.set("underlyingAsset", Value.fromBytes(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get aToken(): string {
    let value = this.get("aToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set aToken(value: string) {
    this.set("aToken", Value.fromString(value));
  }

  get vToken(): string {
    let value = this.get("vToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set vToken(value: string) {
    this.set("vToken", Value.fromString(value));
  }

  get sToken(): string | null {
    let value = this.get("sToken");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set sToken(value: string | null) {
    if (!value) {
      this.unset("sToken");
    } else {
      this.set("sToken", Value.fromString(<string>value));
    }
  }

  get isActive(): boolean {
    let value = this.get("isActive");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isActive(value: boolean) {
    this.set("isActive", Value.fromBoolean(value));
  }

  get isFrozen(): boolean {
    let value = this.get("isFrozen");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isFrozen(value: boolean) {
    this.set("isFrozen", Value.fromBoolean(value));
  }
}

export class SubToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SubToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SubToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("SubToken", id.toString(), this);
    }
  }

  static loadInBlock(id: string): SubToken | null {
    return changetype<SubToken | null>(store.get_in_block("SubToken", id));
  }

  static load(id: string): SubToken | null {
    return changetype<SubToken | null>(store.get("SubToken", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get underlyingAssetAddress(): Bytes {
    let value = this.get("underlyingAssetAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set underlyingAssetAddress(value: Bytes) {
    this.set("underlyingAssetAddress", Value.fromBytes(value));
  }

  get underlyingAssetDecimals(): i32 {
    let value = this.get("underlyingAssetDecimals");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set underlyingAssetDecimals(value: i32) {
    this.set("underlyingAssetDecimals", Value.fromI32(value));
  }

  get tokenContractImpl(): Bytes {
    let value = this.get("tokenContractImpl");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenContractImpl(value: Bytes) {
    this.set("tokenContractImpl", Value.fromBytes(value));
  }
}

export class UserReserve extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserReserve entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UserReserve must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("UserReserve", id.toString(), this);
    }
  }

  static loadInBlock(id: string): UserReserve | null {
    return changetype<UserReserve | null>(
      store.get_in_block("UserReserve", id),
    );
  }

  static load(id: string): UserReserve | null {
    return changetype<UserReserve | null>(store.get("UserReserve", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get pool(): string {
    let value = this.get("pool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set pool(value: string) {
    this.set("pool", Value.fromString(value));
  }

  get reserve(): string {
    let value = this.get("reserve");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set reserve(value: string) {
    this.set("reserve", Value.fromString(value));
  }

  get user(): string {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set user(value: string) {
    this.set("user", Value.fromString(value));
  }

  get scaledATokenBalance(): BigInt {
    let value = this.get("scaledATokenBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set scaledATokenBalance(value: BigInt) {
    this.set("scaledATokenBalance", Value.fromBigInt(value));
  }

  get currentATokenBalance(): BigInt {
    let value = this.get("currentATokenBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currentATokenBalance(value: BigInt) {
    this.set("currentATokenBalance", Value.fromBigInt(value));
  }

  get usageAsCollateralEnabledOnUser(): boolean {
    let value = this.get("usageAsCollateralEnabledOnUser");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set usageAsCollateralEnabledOnUser(value: boolean) {
    this.set("usageAsCollateralEnabledOnUser", Value.fromBoolean(value));
  }

  get scaledVariableDebt(): BigInt {
    let value = this.get("scaledVariableDebt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set scaledVariableDebt(value: BigInt) {
    this.set("scaledVariableDebt", Value.fromBigInt(value));
  }

  get currentVariableDebt(): BigInt {
    let value = this.get("currentVariableDebt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currentVariableDebt(value: BigInt) {
    this.set("currentVariableDebt", Value.fromBigInt(value));
  }

  get principalStableDebt(): BigInt {
    let value = this.get("principalStableDebt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set principalStableDebt(value: BigInt) {
    this.set("principalStableDebt", Value.fromBigInt(value));
  }

  get currentStableDebt(): BigInt {
    let value = this.get("currentStableDebt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currentStableDebt(value: BigInt) {
    this.set("currentStableDebt", Value.fromBigInt(value));
  }

  get currentTotalDebt(): BigInt {
    let value = this.get("currentTotalDebt");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currentTotalDebt(value: BigInt) {
    this.set("currentTotalDebt", Value.fromBigInt(value));
  }

  get variableBorrowIndex(): BigInt {
    let value = this.get("variableBorrowIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set variableBorrowIndex(value: BigInt) {
    this.set("variableBorrowIndex", Value.fromBigInt(value));
  }

  get liquidityIndex(): BigInt {
    let value = this.get("liquidityIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set liquidityIndex(value: BigInt) {
    this.set("liquidityIndex", Value.fromBigInt(value));
  }

  get liquidityRate(): BigInt {
    let value = this.get("liquidityRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set liquidityRate(value: BigInt) {
    this.set("liquidityRate", Value.fromBigInt(value));
  }

  get variableBorrowRate(): BigInt {
    let value = this.get("variableBorrowRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set variableBorrowRate(value: BigInt) {
    this.set("variableBorrowRate", Value.fromBigInt(value));
  }

  get stableBorrowRate(): BigInt {
    let value = this.get("stableBorrowRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set stableBorrowRate(value: BigInt) {
    this.set("stableBorrowRate", Value.fromBigInt(value));
  }

  get stableBorrowLastUpdateTimestamp(): i32 {
    let value = this.get("stableBorrowLastUpdateTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set stableBorrowLastUpdateTimestamp(value: i32) {
    this.set("stableBorrowLastUpdateTimestamp", Value.fromI32(value));
  }

  get lastUpdateTimestamp(): i32 {
    let value = this.get("lastUpdateTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set lastUpdateTimestamp(value: i32) {
    this.set("lastUpdateTimestamp", Value.fromI32(value));
  }
}

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type User must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("User", id.toString(), this);
    }
  }

  static loadInBlock(id: string): User | null {
    return changetype<User | null>(store.get_in_block("User", id));
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get borrowedReservesCount(): i32 {
    let value = this.get("borrowedReservesCount");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set borrowedReservesCount(value: i32) {
    this.set("borrowedReservesCount", Value.fromI32(value));
  }

  get reserves(): UserReserveLoader {
    return new UserReserveLoader(
      "User",
      this.get("id")!.toString(),
      "reserves",
    );
  }
}

export class StableTokenDelegatedAllowance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StableTokenDelegatedAllowance entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StableTokenDelegatedAllowance must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("StableTokenDelegatedAllowance", id.toString(), this);
    }
  }

  static loadInBlock(id: string): StableTokenDelegatedAllowance | null {
    return changetype<StableTokenDelegatedAllowance | null>(
      store.get_in_block("StableTokenDelegatedAllowance", id),
    );
  }

  static load(id: string): StableTokenDelegatedAllowance | null {
    return changetype<StableTokenDelegatedAllowance | null>(
      store.get("StableTokenDelegatedAllowance", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromUser(): string {
    let value = this.get("fromUser");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set fromUser(value: string) {
    this.set("fromUser", Value.fromString(value));
  }

  get toUser(): string {
    let value = this.get("toUser");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set toUser(value: string) {
    this.set("toUser", Value.fromString(value));
  }

  get amountAllowed(): BigInt {
    let value = this.get("amountAllowed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountAllowed(value: BigInt) {
    this.set("amountAllowed", Value.fromBigInt(value));
  }

  get userReserve(): string {
    let value = this.get("userReserve");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set userReserve(value: string) {
    this.set("userReserve", Value.fromString(value));
  }
}

export class VariableTokenDelegatedAllowance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save VariableTokenDelegatedAllowance entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type VariableTokenDelegatedAllowance must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("VariableTokenDelegatedAllowance", id.toString(), this);
    }
  }

  static loadInBlock(id: string): VariableTokenDelegatedAllowance | null {
    return changetype<VariableTokenDelegatedAllowance | null>(
      store.get_in_block("VariableTokenDelegatedAllowance", id),
    );
  }

  static load(id: string): VariableTokenDelegatedAllowance | null {
    return changetype<VariableTokenDelegatedAllowance | null>(
      store.get("VariableTokenDelegatedAllowance", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get fromUser(): string {
    let value = this.get("fromUser");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set fromUser(value: string) {
    this.set("fromUser", Value.fromString(value));
  }

  get toUser(): string {
    let value = this.get("toUser");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set toUser(value: string) {
    this.set("toUser", Value.fromString(value));
  }

  get amountAllowed(): BigInt {
    let value = this.get("amountAllowed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountAllowed(value: BigInt) {
    this.set("amountAllowed", Value.fromBigInt(value));
  }

  get userReserve(): string {
    let value = this.get("userReserve");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set userReserve(value: string) {
    this.set("userReserve", Value.fromString(value));
  }
}

export class PoolLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Pool[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Pool[]>(value);
  }
}

export class UserReserveLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): UserReserve[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<UserReserve[]>(value);
  }
}
