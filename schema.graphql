# Lightweight schema for borrowed users query only
# Optimized for: users(where: {borrowedReservesCount_gt: 0})

type Protocol @entity(immutable: false) {
  id: ID!
  pools: [Pool!]! @derivedFrom(field: "protocol")
}

type ContractToPoolMapping @entity(immutable: false) {
  id: ID!
  pool: Pool!
}

type Pool @entity(immutable: false) {
  id: ID!
  protocol: Protocol!
  pool: Bytes
  active: Boolean!
  paused: Boolean!
}

type Reserve @entity(immutable: false) {
  id: ID!
  underlyingAsset: Bytes!
  pool: Pool!
  symbol: String!
  name: String!
  decimals: Int!

  # Token references
  aToken: SubToken!
  vToken: SubToken!
  sToken: SubToken

  # Minimal state for tracking
  isActive: Boolean!
  isFrozen: Boolean!
}

type SubToken @entity(immutable: false) {
  id: ID!
  pool: Pool!
  underlyingAssetAddress: Bytes!
  underlyingAssetDecimals: Int!
  tokenContractImpl: Bytes!
}

type UserReserve @entity(immutable: false) {
  id: ID!
  pool: Pool!
  reserve: Reserve!
  user: User!

  # Debt tracking (essential for borrowedReservesCount)
  scaledVariableDebt: BigInt!
  currentVariableDebt: BigInt!
  principalStableDebt: BigInt!
  currentStableDebt: BigInt!
  currentTotalDebt: BigInt!

  # Minimal metadata
  lastUpdateTimestamp: Int!
}

type User @entity(immutable: false) {
  id: ID!

  # THIS IS THE KEY FIELD FOR THE QUERY
  borrowedReservesCount: Int!

  # Relations
  reserves: [UserReserve!]! @derivedFrom(field: "user")
}

# Delegated allowances (needed for debt token events)
type StableTokenDelegatedAllowance @entity(immutable: false) {
  id: ID!
  fromUser: String!
  toUser: String!
  amountAllowed: BigInt!
  userReserve: UserReserve!
}

type VariableTokenDelegatedAllowance @entity(immutable: false) {
  id: ID!
  fromUser: String!
  toUser: String!
  amountAllowed: BigInt!
  userReserve: UserReserve!
}
